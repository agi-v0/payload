---
description: Creating a payload cms schema for a content block, registering it, and linking it to the nextjs frontend.
globs: 
alwaysApply: false
---
**Guideline: Creating Payload Blocks with Variants**

This guideline assumes you are using Payload CMS with Next.js (App Router) and TypeScript, aiming for a modular structure where blocks can have multiple visual presentations (variants).

**1. Directory Structure:**

Organize each block within its own directory under `src/blocks/`. Include subdirectories for specific variant components.

```
src/
├── blocks/
│   ├── [BlockName]/                 # Example: TestimonialsBlock
│   │   ├── config.ts                # Payload Block Schema definition
│   │   ├── Render[BlockName].tsx    # Router/Data Fetching Component (Server Component)
│   │   ├── [VariantName01]/         # Example: TestimonialsBlock01
│   │   │   └── index.tsx            # Component for Variant 01 (Client or Server)
│   │   ├── [VariantName02]/         # Example: TestimonialsSlider
│   │   │   └── index.tsx            # Component for Variant 02
│   │   └── ...                      # Other variants
│   └── BlockHeader/                 # Reusable Block Header components/config
│       ├── config.ts
│       └── RenderBlockHeader.tsx
└── collections/
    └── Pages/                     # Or wherever the block is used
        └── index.ts               # Collection config
```

**2. Block Schema Definition (`config.ts`)**

*   **Imports:** Import `Block`, `Field` from `payload`, and any reusable field definitions (e.g., `blockHeader`, `linkGroup`).
*   **`slug`:** A unique, descriptive, camelCase identifier (e.g., `testimonials`). This is used internally and often in the `blockType` property.
*   **`interfaceName`:** A PascalCase name used for TypeScript type generation (e.g., `TestimonialsBlock`).
*   **`fields` Array:**
    *   **`blockHeader` (Recommended):** Include the shared `blockHeader` field (`import { blockHeader } from '@/blocks/BlockHeader/config'`) as the first field for consistency.
    *   **`type` (For Variants):** Add a `select` field named `type`.
        *   Define `options` with `value` (unique identifier for the variant, e.g., `testimonialsGrid`) and `label` (user-friendly name, e.g., 'Testimonials Grid').
        *   Set `required: true` and provide a sensible `defaultValue`.
    *   **Content Fields:** Define fields specific to this block (e.g., `relationship` to select related data like testimonials or apps, `richText`, `upload` for media).
    *   **Relationship Fields:**
        *   Clearly define `relationTo`.
        *   Use `hasMany` if multiple selections are allowed.
        *   Provide helpful `admin.description`.
        *   Remember relationship data structure: `{ relationTo, value }` where `value` is the ID or the populated object.
    *   **`dbName` (Conditional):** If a field name, especially one nested within groups/arrays/blocks, could lead to generated database identifiers exceeding limits (e.g., 63 chars in Postgres), add `dbName: 'short_explicit_name'` at the top level of the field definition.
*   **Export:** Export the complete `Block` configuration object.

```typescript
// src/blocks/TestimonialsBlock/config.ts
import type { Block, Field } from 'payload'
import { blockHeader } from '@/blocks/BlockHeader/config'

const fields: Field[] = [
  {
    name: 'type',
    type: 'select',
    options: [
      { value: 'testimonialsGrid', label: 'Testimonials Grid' },
      { value: 'testimonialsSlider', label: 'Testimonials Slider' },
    ],
    required: true,
    defaultValue: 'testimonialsGrid',
  },
  {
    name: 'selectedTestimonials',
    type: 'relationship',
    relationTo: ['testimonials'],
    hasMany: true,
    // ... admin config
  },
  // ... other fields
]

export const TestimonialsBlock: Block = {
  slug: 'testimonials',
  interfaceName: 'TestimonialsBlock',
  fields: [blockHeader, ...fields],
}
```

**3. Router/Data Fetching Component (`Render[BlockName].tsx`)**

*   **Component Type:** MUST be an `async` React Server Component (RSC).
*   **Imports:**
    *   `React`, `Fragment`, `lazy` (if using lazy loading, though direct Suspense in RSCs is limited).
    *   `getPayload` from `'payload'`.
    *   `config` from `'@payload-config'`.
    *   `getLocale` from `'next-intl/server'`.
    *   Generated Payload types (`Page`, `[BlockName]Type`, related collection types like `Testimonial`).
    *   Variant components (using `lazy` or direct imports).
    *   `RenderBlockHeader` if used centrally here.
*   **Type Definition:** Use the generated block type (e.g., `TestimonialsBlockType`).
*   **Props:** Receive the block data (`props: TestimonialsBlockType`).
*   **Get Locale:** `const locale = await getLocale()`.
*   **Get Payload:** `const payload = await getPayload({ config })`.
*   **Data Fetching Logic:**
    *   Fetch related data based on relationship fields (e.g., `selectedTestimonials`).
    *   Handle the relationship data structure correctly (e.g., `props.selectedTestimonials.map(t => t.value)`).
    *   Use `payload.find` with `locale: locale as 'en' | 'ar'` (or your specific locales) and `fallbackLocale`. Set `depth` appropriately.
    *   Implement logic for fallback data (e.g., fetch recent items if none are selected).
    *   Wrap fetching in `try...catch` for error handling.
*   **Variant Mapping:** Create an object mapping `type` values to the imported variant components.
*   **Rendering:**
    *   Check if data exists; return `null` or a placeholder if not.
    *   Get the correct `BlockComponent` from the map based on `props.type`.
    *   Render the shared `BlockHeader` if applicable (using `props.blockHeader`).
    *   Render the selected `BlockComponent`, passing the fetched data as props.
    *   Use `<Fragment>` if no wrapper element is needed.

```typescript
// src/blocks/TestimonialsBlock/RenderTestimonialsBlock.tsx
import React, { Fragment, lazy } from 'react'
import { getLocale } from 'next-intl/server'
import { getPayload } from 'payload'
import config from '@payload-config'
import type { TestimonialsBlock as TestimonialsBlockType, Testimonial } from '@/payload-types'
import { RenderBlockHeader } from '@/blocks/BlockHeader/RenderBlockHeader'
import { TestimonialsGrid } from './TestimonialsGrid' // Or lazy load

const blockComponents = {
  testimonialsGrid: TestimonialsGrid,
  // testimonialsSlider: TestimonialsSlider,
}

export const RenderTestimonialsBlock: React.FC<TestimonialsBlockType> = async (props) => {
  const { type, blockHeader, selectedTestimonials } = props
  const locale = await getLocale()
  const payload = await getPayload({ config })
  let testimonialsToRender: Testimonial[] = []

  // --- Data fetching logic (try/catch) ---
  // Fetch based on selectedTestimonials (using .map(t => t.value))
  // Or fetch recent if none selected
  // Set testimonialsToRender
  // --- End Data fetching ---

  if (!testimonialsToRender || testimonialsToRender.length === 0) return null

  const BlockComponent = blockComponents[type as keyof typeof blockComponents]
  if (!BlockComponent) return null // Or log warning

  return (
    <Fragment>
      {blockHeader && <RenderBlockHeader blockHeader={blockHeader} />}
      <BlockComponent testimonials={testimonialsToRender} />
    </Fragment>
  )
}
```

**4. Variant Component (`[VariantName]/index.tsx`)**

*   **Component Type:** Can be a Server or Client Component (`'use client'`) depending on whether it needs interactivity (state, effects, event handlers).
*   **Imports:** Import `React` and necessary types/components (Payload types, UI components like Shadcn/UI, Payload RichText renderer).
*   **Props:** Define an interface for the props it receives from the Router component (e.g., `testimonials: Testimonial[]`).
*   **Rendering:**
    *   Focus *only* on the JSX structure and styling for this specific visual variant.
    *   Map over the data array (`testimonials`) to render individual items/cards.
    *   Use UI library components (`Card`, `Carousel`, etc.).
    *   Use the Payload RichText component to render Rich Text fields correctly.
    *   Apply Tailwind/CSS classes.

```typescript
// src/blocks/TestimonialsBlock/TestimonialsGrid/index.tsx
import React from 'react'
import { Testimonial } from '@/payload-types'
// Import Card components, RichText renderer etc.

interface TestimonialsGridProps {
  testimonials: Testimonial[]
}

export const TestimonialsGrid: React.FC<TestimonialsGridProps> = ({ testimonials }) => {
  return (
    <section className="container py-12">
      <div className="grid ...">
        {testimonials.map((testimonial) => (
          <div key={testimonial.id} className="border p-4">
            {/* Render testimonial.quote using RichText component */}
            <p>- {testimonial.authorName}</p>
          </div>
        ))}
      </div>
    </section>
  )
}
```

**5. Block Registration**

*   Import the block's `config` into the collection config where it will be used (e.g., `src/collections/Pages/index.ts`).
*   Add the imported block config object to the `blocks` array within the appropriate `blocks` type field (e.g., `layout`).

```typescript
// src/collections/Pages/index.ts
import { TestimonialsBlock } from '@/blocks/TestimonialsBlock/config'
// ... other block imports

export const Pages: CollectionConfig = {
  // ...
  fields: [
    // ... other fields
    {
      name: 'layout',
      type: 'blocks',
      blocks: [
        // ... other blocks
        TestimonialsBlock,
      ],
    },
  ],
}
```

**6. Type Generation (CRITICAL STEP)**

*   **AFTER ANY CHANGE** to a block's `config.ts` or related collection fields:
*   **Run `pnpm generate:types`** (or your project's equivalent command).
*   This updates `@/payload-types.ts`, ensuring your components use the correct types and avoiding `Property '...' does not exist` errors.

**7. Update Block Renderer (`src/blocks/RenderBlocks.tsx`)**

*   Import the main Router component (e.g., `RenderTestimonialsBlock`).
*   Add an entry to the `blockComponents` map, mapping the block's `slug` to the imported component.

```typescript
// src/blocks/RenderBlocks.tsx
import { RenderTestimonialsBlock } from './TestimonialsBlock/RenderTestimonialsBlock'
// ... other imports

const blockComponents = {
  // ... other blocks
  testimonials: RenderTestimonialsBlock,
}
// ... rest of component
```

By following these steps, you create modular, type-safe, and flexible blocks that can easily accommodate different designs and integrate smoothly with Payload and Next.js. Remember that regenerating types is the most crucial step after schema modifications.
